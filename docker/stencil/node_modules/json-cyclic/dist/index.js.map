{"version":3,"file":"index.js","sources":["../src/utils/utils.js","../src/validate/validate.js","../src/encycle/encycle.js","../src/decycle/decycle.js"],"sourcesContent":["export const isArray = (value) => Array.isArray(value);\n\nexport const isObject = (value) =>\n  Object.prototype.toString.call(value).slice(8, -1) === \"Object\";\n","import { isArray, isObject } from \"../utils\";\n\nexport const validate = (value) => {\n  if (typeof value === \"undefined\") {\n    throw new Error(\"This method requires one parameter\");\n  }\n\n  if (!isArray(value) && !isObject(value)) {\n    throw new TypeError(\"This method only accepts arrays and objects\");\n  }\n};\n\nexport default validate;\n","import { isArray, isObject } from \"../utils\";\nimport validate from \"../validate\";\n\nexport const isRef = (value) =>\n  isObject(value) &&\n  value.hasOwnProperty(\"$ref\") &&\n  Object.keys(value).length === 1 &&\n  !!value.$ref &&\n  value.$ref.charAt(0) === \"$\";\n\nexport const encycle = (arg) => {\n  validate(arg);\n\n  const recurs = (value) => {\n    if (isArray(value) || isObject(value)) {\n      if (isArray(value)) {\n        return value.map((elem, i) => {\n          if (isRef(elem)) {\n            value[i] = eval(\"arg\" + elem.$ref.slice(1));\n\n            return value;\n          }\n\n          return recurs(elem);\n        });\n      }\n\n      return Object.keys(value).reduce((accum, key) => {\n        if (isRef(value[key])) {\n          accum[key] = eval(\"arg\" + value[key].$ref.slice(1));\n        } else {\n          accum[key] = recurs(value[key]);\n        }\n\n        return accum;\n      }, value);\n    }\n\n    return value;\n  };\n\n  return recurs(arg);\n};\n\nexport default encycle;\n","import { isArray, isObject } from \"../utils\";\nimport validate from \"../validate\";\n\nexport const findRef = (ref, visitedRefs) =>\n  Object.keys(visitedRefs).find((key) => visitedRefs[key] === ref);\n\nexport const decycle = (arg) => {\n  validate(arg);\n\n  let visitedRefs = {};\n\n  const recurs = (value, path = \"$\") => {\n    const ref = findRef(value, visitedRefs);\n\n    if (ref) {\n      return { $ref: ref };\n    }\n\n    if (isArray(value) || isObject(value)) {\n      visitedRefs[path] = value;\n\n      if (isArray(value)) {\n        return value.map((elem, i) => recurs(elem, `${path}[${i}]`));\n      }\n\n      return Object.keys(value).reduce((accum, key) => {\n        accum[key] = recurs(value[key], `${path}.${key}`);\n\n        return accum;\n      }, {});\n    }\n\n    return value;\n  };\n\n  return recurs(arg);\n};\n\nexport default decycle;\n"],"names":["isArray","value","Array","isObject","Object","prototype","toString","call","slice","validate","Error","TypeError","isRef","hasOwnProperty","keys","length","$ref","charAt","encycle","arg","recurs","map","elem","i","eval","reduce","accum","key","findRef","ref","visitedRefs","find","decycle","path"],"mappings":"MAAaA,QAAWC,GAAUC,MAAMF,QAAQC,GAEnCE,SAAYF,GACgC,WAAvDG,OAAOC,UAAUC,SAASC,KAAKN,GAAOO,MAAM,GAAI,GCDrCC,SAAYR,IACvB,QAAqB,IAAVA,EACT,UAAUS,MAAM,sCAGlB,IAAKV,QAAQC,KAAWE,SAASF,GAC/B,UAAUU,UAAU,gDCLXC,MAASX,GACpBE,SAASF,IACTA,EAAMY,eAAe,SACS,IAA9BT,OAAOU,KAAKb,GAAOc,UACjBd,EAAMe,MACiB,MAAzBf,EAAMe,KAAKC,OAAO,GAEPC,QAAWC,MACtBV,SAASU,KAET,MAAMC,OAAUnB,OACVD,QAAQC,QAAUE,SAASF,OACzBD,QAAQC,OACHA,MAAMoB,IAAI,CAACC,KAAMC,IAClBX,MAAMU,OACRrB,MAAMsB,GAAKC,KAAK,MAAQF,KAAKN,KAAKR,MAAM,IAEjCP,OAGFmB,OAAOE,OAIXlB,OAAOU,KAAKb,OAAOwB,OAAO,CAACC,MAAOC,OAErCD,MAAMC,KADJf,MAAMX,MAAM0B,MACDH,KAAK,MAAQvB,MAAM0B,KAAKX,KAAKR,MAAM,IAEnCY,OAAOnB,MAAM0B,MAGrBD,OACNzB,OAGEA,MAGT,OAAOmB,OAAOD,MCtCHS,QAAU,CAACC,EAAKC,IAC3B1B,OAAOU,KAAKgB,GAAaC,KAAMJ,GAAQG,EAAYH,KAASE,GAEjDG,QAAWb,IACtBV,SAASU,GAET,IAAIW,EAAc,GAElB,MAAMV,EAAS,CAACnB,EAAOgC,EAAO,OAC5B,MAAMJ,EAAMD,QAAQ3B,EAAO6B,GAE3B,OAAID,EACK,CAAEb,KAAMa,GAGb7B,QAAQC,IAAUE,SAASF,IAC7B6B,EAAYG,GAAQhC,EAEhBD,QAAQC,GACHA,EAAMoB,IAAI,CAACC,EAAMC,IAAMH,EAAOE,EAAO,GAAEW,KAAQV,OAGjDnB,OAAOU,KAAKb,GAAOwB,OAAO,CAACC,EAAOC,KACvCD,EAAMC,GAAOP,EAAOnB,EAAM0B,GAAO,GAAEM,KAAQN,KAEpCD,GACN,KAGEzB,GAGT,OAAOmB,EAAOD"}
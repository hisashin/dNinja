!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r((e=e||self).jsonCyclic={})}(this,function(exports){const isArray=e=>Array.isArray(e),isObject=e=>"Object"===Object.prototype.toString.call(e).slice(8,-1),validate=e=>{if(void 0===e)throw new Error("This method requires one parameter");if(!isArray(e)&&!isObject(e))throw new TypeError("This method only accepts arrays and objects")},isRef=e=>isObject(e)&&e.hasOwnProperty("$ref")&&1===Object.keys(e).length&&!!e.$ref&&"$"===e.$ref.charAt(0),encycle=arg=>{validate(arg);const recurs=value=>isArray(value)||isObject(value)?isArray(value)?value.map((elem,i)=>isRef(elem)?(value[i]=eval("arg"+elem.$ref.slice(1)),value):recurs(elem)):Object.keys(value).reduce((accum,key)=>(accum[key]=isRef(value[key])?eval("arg"+value[key].$ref.slice(1)):recurs(value[key]),accum),value):value;return recurs(arg)},findRef=(e,r)=>Object.keys(r).find(c=>r[c]===e),decycle=e=>{validate(e);let r={};const c=(e,t="$")=>{const a=findRef(e,r);return a?{$ref:a}:isArray(e)||isObject(e)?(r[t]=e,isArray(e)?e.map((e,r)=>c(e,`${t}[${r}]`)):Object.keys(e).reduce((r,a)=>(r[a]=c(e[a],`${t}.${a}`),r),{})):e};return c(e)};exports.decycle=decycle,exports.encycle=encycle});
//# sourceMappingURL=index.umd.js.map

const isArray=e=>Array.isArray(e),isObject=e=>"Object"===Object.prototype.toString.call(e).slice(8,-1),validate=e=>{if(void 0===e)throw new Error("This method requires one parameter");if(!isArray(e)&&!isObject(e))throw new TypeError("This method only accepts arrays and objects")},isRef=e=>isObject(e)&&e.hasOwnProperty("$ref")&&1===Object.keys(e).length&&!!e.$ref&&"$"===e.$ref.charAt(0),encycle=arg=>{validate(arg);const recurs=value=>isArray(value)||isObject(value)?isArray(value)?value.map((elem,i)=>isRef(elem)?(value[i]=eval("arg"+elem.$ref.slice(1)),value):recurs(elem)):Object.keys(value).reduce((accum,key)=>(accum[key]=isRef(value[key])?eval("arg"+value[key].$ref.slice(1)):recurs(value[key]),accum),value):value;return recurs(arg)},findRef=(e,r)=>Object.keys(r).find(a=>r[a]===e),decycle=e=>{validate(e);let r={};const a=(e,c="$")=>{const s=findRef(e,r);return s?{$ref:s}:isArray(e)||isObject(e)?(r[c]=e,isArray(e)?e.map((e,r)=>a(e,`${c}[${r}]`)):Object.keys(e).reduce((r,s)=>(r[s]=a(e[s],`${c}.${s}`),r),{})):e};return a(e)};export{decycle,encycle};
//# sourceMappingURL=index.modern.js.map
